package recipe

import (
	"fmt"
	"strconv"
)

//List - struct for list of recipes
type List struct {
	Count      int        `bson:"count,omitempty" json:"count,omitempty"`
	Offset     int        `bson:"offset_index,omitempty" json:"offset_index,omitempty"`
	Limit      int        `bson:"limit,omitempty" json:"limit,omitempty"`
	Items      []Response `bson:"items,omitempty" json:"items,omitempty"`
	TotalCount int        `bson:"total_count,omitempty" json:"total_count,omitempty"`
}

//Response - struct for individual recipe
type Response struct {
	ID              string     `bson:"_id,omitempty" json:"id,omitempty"`
	Alias           string     `bson:"alias,omitempty" json:"alias,omitempty"`
	Format          string     `bson:"format,omitempty" json:"format,omitempty"`
	InputFiles      []file     `bson:"files,omitempty" json:"files,omitempty"`
	OutputInstances []Instance `bson:"output_instances,omitempty" json:"output_instances,omitempty"`
}

//CodeList - Code lists for instance
type CodeList struct {
	ID          string `bson:"id,omitempty" json:"id,omitempty"`
	HRef        string `bson:"href,omitempty" json:"href,omitempty"`
	Name        string `bson:"name,omitempty" json:"name,omitempty"`
	IsHierarchy *bool  `bson:"is_hierarchy,omitempty" json:"is_hierarchy,omitempty"`
}

//Instance - struct for instance of recipe
type Instance struct {
	DatasetID string     `bson:"dataset_id,omitempty" json:"dataset_id,omitempty"`
	Editions  []string   `bson:"editions,omitempty" json:"editions,omitempty"`
	Title     string     `bson:"title,omitempty" json:"title,omitempty"`
	CodeLists []CodeList `bson:"code_lists,omitempty" json:"code_lists,omitempty"`
}

type file struct {
	Description string `bson:"description,omitempty" json:"description,omitempty"`
}

//ValidateAddRecipe - checks if all the fields are non-empty
func (recipe *Response) ValidateAddRecipe() error {
	var missingFields []string
	var invalidFields []string
	validFormats := map[string]bool{
		"v4": true,
	}

	//recipe.ID generated by API if ID not given so never missing (generates a V4 UUID)

	if recipe.Alias == "" {
		missingFields = append(missingFields, "alias")
	}
	if recipe.Format == "" {
		missingFields = append(missingFields, "format")
	} else {
		if !validFormats[recipe.Format] {
			invalidFields = append(invalidFields, "format is not valid")
		}
	}

	if recipe.InputFiles != nil {
		for i, file := range recipe.InputFiles {
			if file.Description == "" {
				missingFields = append(missingFields, "input-files["+strconv.Itoa(i)+"].description")
			}
		}
	} else {
		missingFields = append(missingFields, "input-files")
	}

	if recipe.OutputInstances != nil {
		for instanceCount, instance := range recipe.OutputInstances {
			instance.ValidateInstance("recipe", missingFields, invalidFields, instanceCount)
		}
	} else {
		missingFields = append(missingFields, "output-instances")
	}

	if missingFields != nil {
		return fmt.Errorf("missing mandatory fields: %v", missingFields)
	}

	if invalidFields != nil {
		return fmt.Errorf("invalid fields: %v", invalidFields)
	}

	return nil

}

//ValidateUpdateRecipe - checks updates of recipe for PUT request
func (recipe *Response) ValidateUpdateRecipe(level string) error {
	var missingFields []string
	var invalidFields []string
	validFormats := map[string]bool{
		"v4": true,
	}

	if level == "recipe" {
		allStringFieldsEmpty := recipe.ID == "" && recipe.Format == "" && recipe.Alias == ""
		allRemainingFieldsNil := recipe.InputFiles == nil && recipe.OutputInstances == nil
		if allStringFieldsEmpty && allRemainingFieldsNil {
			invalidFields = append(invalidFields, "no recipe fields updates given")
		}
	}

	if recipe.ID != "" {
		invalidFields = append(invalidFields, "id cannot be changed")
	}
	if recipe.Format != "" {
		if !validFormats[recipe.Format] {
			invalidFields = append(invalidFields, "format is not valid")
		}
	}

	if recipe.InputFiles != nil {
		for i, file := range recipe.InputFiles {
			if file.Description == "" {
				missingFields = append(missingFields, "input-files["+strconv.Itoa(i)+"].description")
			}
		}
	}

	fmt.Println(missingFields)

	if recipe.OutputInstances != nil {
		for instanceCount, instance := range recipe.OutputInstances {
			instance.ValidateInstance(level, missingFields, invalidFields, instanceCount)
		}
	}

	fmt.Println(missingFields)

	if missingFields != nil {
		return fmt.Errorf("missing mandatory fields: %v", missingFields)
	}

	if invalidFields != nil {
		return fmt.Errorf("invalid fields: %v", invalidFields)
	}

	return nil

}

//ValidateInstance - checks if fields of OutputInstances is not empty for ValidateAddRecipe and
func (instance *Instance) ValidateInstance(level string, missingFields []string, invalidFields []string, instanceCount int) error {

	if level == "instance" {
		allStringFieldsEmpty := instance.DatasetID == "" && instance.Title == ""
		allRemainingFieldsNil := instance.Editions == nil && instance.CodeLists == nil
		if allStringFieldsEmpty && allRemainingFieldsNil {
			invalidFields = append(invalidFields, "no instance fields updates given")
		}
	}

	if instance.DatasetID == "" {
		if level == "recipe" {
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].dataset-id")
		}
	} else {
		if level == "instance" {
			invalidFields = append(invalidFields, "dataset-id cannot be changed")
		}
	}

	if instance.Editions != nil {
		for j, edition := range instance.Editions {
			if edition == "" {
				switch level {
				case "recipe":
					missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].editions["+strconv.Itoa(j)+"]")
				case "instance":
					missingFields = append(missingFields, "editions["+strconv.Itoa(j)+"]")
				}
			}
		}
	} else {
		if level == "recipe" {
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].editions")
		}
	}

	if instance.Title == "" {
		if level == "recipe" {
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].title")
		}
	}

	if instance.CodeLists != nil {
		for codelistCount, codelist := range instance.CodeLists {
			codelist.ValidateCodelists(level, missingFields, invalidFields, instanceCount, codelistCount)
		}
	} else {
		if level == "recipe" {
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].codelists")
		}
	}

	fmt.Println(missingFields)

	if level == "instance" {
		// If any fields missing from the codelists of the instance
		if missingFields != nil {
			return fmt.Errorf("missing mandatory fields: %v", missingFields)
		}

		if invalidFields != nil {
			return fmt.Errorf("invalid fields: %v", invalidFields)
		}
	}

	return nil

}

//ValidateCodelists - checks if fields of CodeList is not empty
func (codelist *CodeList) ValidateCodelists(level string, missingFields []string, invalidFields []string, instanceCount int, codelistCount int) error {

	if level == "codelist" {
		allStringFieldsEmpty := codelist.ID == "" && codelist.Name == "" && codelist.HRef == ""
		if allStringFieldsEmpty && codelist.IsHierarchy == nil {
			invalidFields = append(invalidFields, "no codelist fields updates given")
		}
	}

	if codelist.ID == "" {
		switch level {
		case "recipe":
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].codelists["+strconv.Itoa(codelistCount)+"].id")
		case "instance":
			missingFields = append(missingFields, "codelists["+strconv.Itoa(codelistCount)+"].id")
		}
	} else {
		if level == "codelist" {
			invalidFields = append(invalidFields, "id cannot be changed")
		}
	}

	if codelist.HRef == "" {
		switch level {
		case "recipe":
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].codelists["+strconv.Itoa(codelistCount)+"].href")
		case "instance":
			missingFields = append(missingFields, "codelists["+strconv.Itoa(codelistCount)+"].href")
		}
	}

	if codelist.Name == "" {
		switch level {
		case "recipe":
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].codelists["+strconv.Itoa(codelistCount)+"].name")
		case "instance":
			missingFields = append(missingFields, "codelists["+strconv.Itoa(codelistCount)+"].name")
		}
	}

	if codelist.IsHierarchy == nil {
		switch level {
		case "recipe":
			missingFields = append(missingFields, "output-instances["+strconv.Itoa(instanceCount)+"].codelists["+strconv.Itoa(codelistCount)+"].isHierarchy")
		case "instance":
			missingFields = append(missingFields, "codelists["+strconv.Itoa(codelistCount)+"].isHierarchy")
		}
	}

	if level == "codelist" {
		if invalidFields != nil {
			return fmt.Errorf("invalid fields: %v", invalidFields)
		}
	}

	return nil
}
